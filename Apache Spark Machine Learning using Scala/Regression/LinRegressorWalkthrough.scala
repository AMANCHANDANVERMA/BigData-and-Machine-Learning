// To start a new Spark Session
import org.apache.spark.sql.SparkSession

// To import Linear Regression Algorithm
import org.apache.spark.ml.regression.LinearRegression

// To create error logs
import org.apache.log4j._

// To format data into dataframes (label,features)
import org.apache.spark.ml.feature.VectorAssembler

Logger.getLogger("org").setLevel(Level.ERROR)

val spark = SparkSession.builder().getOrCreate()

// Load input data
val data = spark.read.option("Header","true").option("inferSchema","true").format("csv").load("Clean-USA-Housing.csv")
// data.printSchema

// data.head(1)
// Print data
// val colnames = data.columns
// val firstrow = data.head(1)(0)
// for (ind <- Range(1,colnames.length))
// {
//   println(colnames(ind))
//   println(firstrow(ind))
//   println("\n")
// }

// label: Price of House
val df = (data.select(data("Price").as("label"),
          $"Avg Area Income", $"Avg Area House Age",
          $"Avg Area Number of Rooms", $"Avg Area Number of Bedrooms",
          $"Area Population"))
// df.printSchema


// VectorAssembler is a transformer that combines a given list of columns into a single vector column.
// It is useful for combining raw features and features generated by different feature transformers into
// a single feature vector, in order to train ML models like logistic regression and decision trees.

// Set All features an Input Columns and create a vector for them
// Takes input from all columns, puts it into an array and name it Features
val assembler = (new VectorAssembler()
                  .setInputCols(Array("Avg Area Income",
                    "Avg Area House Age","Avg Area Number of Rooms",
                    "Avg Area Number of Bedrooms","Area Population"))
                    .setOutputCol("features"))

// Vector Assembler returns all columns along with Features Column.
// To use only Labels and Features columns, use ".select"
val output = assembler.transform(df).select($"label",$"features")
// output.show()

// Create Linear Regression Object
val lr = new LinearRegression().setMaxIter(100).setRegParam(0.3).setElasticNetParam(0.8)

// Fit the Model
val lrModel = lr.fit(output)

// Print coefficients and intercept for Linear regression
// println(s"Coefficients: ${lrModel.coefficients} Intercept: ${lrModel.intercept}")

// Summarize the model over training set and print out some metrics
val trainingSummary = lrModel.summary
// println(s"numIterations: ${trainingSummary.totalIterations}")
// println(s"objectiveHitory: ${trainingSummary.objectiveHistory.toList}")
// Residuals: Difference between Predicted and Actual Value (y - y^)
trainingSummary.residuals.show()
println()
trainingSummary.predictions.show()
// Root Mean Square Error:  sqrt((1/n)*summation((y-y^)^2))
println(s"RootMeanSquareError: ${trainingSummary.rootMeanSquaredError}")
println(s"R^2 Vallue: ${trainingSummary.r2}")
